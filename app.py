import os
import random
import tldextract
import pandas as pd
from flask import Flask, render_template, request, redirect, url_for, flash, jsonify, send_from_directory
from werkzeug.utils import secure_filename
from flask_cors import CORS

# PDF
from reportlab.lib.pagesizes import A4
from reportlab.pdfgen import canvas

# ===============================
# PROJECT ROOT
# ===============================
PROJECT_ROOT = os.path.dirname(os.path.abspath(__file__))

from utils import load_model, align_and_scale_features, predictions_to_labels

# ===============================
# OPTIONAL: NFStreamer
# ===============================
try:
    from nfstream import NFStreamer
    NFSTREAM_AVAILABLE = True
except:
    NFSTREAM_AVAILABLE = False

# ===============================
# FLASK SETUP
# ===============================
app = Flask(__name__)
CORS(app)
app.secret_key = "networkanalyzer2025"

UPLOAD_FOLDER = os.path.join(PROJECT_ROOT, "data", "uploads")
DATA_FOLDER = os.path.join(PROJECT_ROOT, "data")

os.makedirs(UPLOAD_FOLDER, exist_ok=True)
os.makedirs(DATA_FOLDER, exist_ok=True)

# ===============================
# LOAD MODEL
# ===============================
MODEL, SCALER = load_model()

# ===============================
# FEATURE GENERATION
# ===============================
def simulate_features(seed_text):
    seed = sum(ord(c) for c in seed_text)
    rnd = random.Random(seed)

    return pd.DataFrame({
        "bytes": [rnd.randint(2000, 120000)],
        "packets": [rnd.randint(10, 800)],
        "duration": [rnd.uniform(0.1, 5.0)]
    })


def extract_features_nfstream(file_path):
    records = []
    try:
        streamer = NFStreamer(source=file_path, statistical_analysis=True)
        for flow in streamer:
            records.append([
                flow.bidirectional_bytes,
                flow.bidirectional_packets,
                getattr(flow, "bidirectional_duration_ms", 0) / 1000
            ])
        return pd.DataFrame(records, columns=["bytes", "packets", "duration"])
    except:
        return pd.DataFrame()

# ===============================
# PDF REPORT GENERATOR âœ…
# ===============================
def generate_pdf_report(path, filename, final_label, confidence, risk, reasons):
    c = canvas.Canvas(path, pagesize=A4)
    width, height = A4

    y = height - 60

    c.setFont("Helvetica-Bold", 20)
    c.drawString(50, y, "Network Traffic Security Report")

    y -= 40
    c.setFont("Helvetica", 12)
    c.drawString(50, y, f"File Analyzed: {filename}")

    y -= 25
    c.drawString(50, y, f"Final Verdict: {final_label.upper()}")

    y -= 20
    c.drawString(50, y, f"Risk Level: {risk}")

    y -= 20
    c.drawString(50, y, f"Model Confidence: {confidence}%")

    y -= 35
    c.setFont("Helvetica-Bold", 14)
    c.drawString(50, y, "Explainable AI â€“ Reasons")

    y -= 25
    c.setFont("Helvetica", 11)
    for r in reasons:
        c.drawString(70, y, f"- {r}")
        y -= 18

    y -= 30
    c.setFont("Helvetica-Oblique", 10)
    c.drawString(50, y, "Generated by ML-based Network Traffic Analyzer")

    c.showPage()
    c.save()

# ===============================
# ROUTES
# ===============================
@app.route("/")
def index():
    return render_template("dashboard.html")


# ðŸ”½ DOWNLOAD PDF ROUTE
@app.route("/data/<path:filename>")
def download_report(filename):
    return send_from_directory(DATA_FOLDER, filename, as_attachment=True)


@app.route("/results", methods=["POST"])
def results():
    if "file" not in request.files:
        flash("No file uploaded")
        return redirect(url_for("index"))

    file = request.files["file"]
    if file.filename == "":
        flash("No selected file")
        return redirect(url_for("index"))

    filename = secure_filename(file.filename)
    file_path = os.path.join(UPLOAD_FOLDER, filename)
    file.save(file_path)

    # FEATURE EXTRACTION
    if NFSTREAM_AVAILABLE:
        df = extract_features_nfstream(file_path)
        if df.empty:
            df = simulate_features(filename)
    else:
        df = simulate_features(filename)

    X_scaled = align_and_scale_features(df, SCALER)

    # CONFIDENCE
    if hasattr(MODEL, "predict_proba"):
        confidence = round(float(MODEL.predict_proba(X_scaled).max()) * 100, 2)
    else:
        confidence = 75.0

    bytes_val = df["bytes"].iloc[0]
    packets_val = df["packets"].iloc[0]
    duration_val = df["duration"].iloc[0]

    # HYBRID LOGIC
    if bytes_val > 100000 or packets_val > 700:
        final_label = "attack"
        risk = "HIGH"
    elif bytes_val > 50000 or packets_val > 400:
        final_label = "attack"
        risk = "MEDIUM"
    else:
        final_label = "normal"
        risk = "LOW"

    # EXPLAINABLE AI
    reasons = []
    if bytes_val > 100000:
        reasons.append("Unusually high data volume detected")
    if packets_val > 700:
        reasons.append("Abnormal packet rate observed")
    if duration_val > 4:
        reasons.append("Long connection duration")
    if not reasons:
        reasons.append("Traffic behavior within normal limits")

    total_packets = 1
    attack_packets = 1 if final_label == "attack" else 0
    attack_percentage = round((attack_packets / total_packets) * 100, 2)

    # PDF REPORT
    report_filename = f"report_{filename}.pdf"
    report_path = os.path.join(DATA_FOLDER, report_filename)

    generate_pdf_report(
        report_path,
        filename,
        final_label,
        confidence,
        risk,
        reasons
    )

    return render_template(
        "results.html",
        results={
            "filename": filename,
            "attack": attack_packets,
            "total_packets": total_packets,
            "attack_percentage": attack_percentage,
            "confidence": confidence,
            "risk": risk,
            "final_label": final_label,
            "reasons": reasons
        },
        report_file=f"/data/{report_filename}"
    )


if __name__ == "__main__":
    app.run(debug=True)
